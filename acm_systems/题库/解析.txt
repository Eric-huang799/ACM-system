[ID:1]
[answer]
#include <stdio.h>
int main() {
    int a, b;
    scanf("%d %d", &a, &b);
    printf("%d\n", a + b);
    return 0;
}

[分析] 
这是一道入门题目，考察基础的输入输出和加法运算。
核心思路：
1. 使用scanf读取两个整数
2. 计算它们的和
3. 使用printf输出结果
---
[ID:2]
[answer]
#include<stdio.h>
int main(){
	int a,b,c;
	scanf("%d %d",&a,&b);
	c=a+b;
	printf("%d",c);
	return 0;
}

[分析] 
1. 本题要求输入两个整数，并求这两整数的和，则本题的核心是读取两个
整数并输出他们的和。
2. 本题的解题思路为：首先通过 scanf 读取两个整数，然后对两个整数执行
加法运算，最后通过 print 输出求和后的结果。
---
[ID:3]
[answer]
#include <stdio.h>
#include <stdlib.h>
#define MAXV 1000
#define MAXN 1000
int main(void)
{
    int N, V;
    if (scanf("%d %d", &N, &V) != 2) return 0;

    int vol[MAXN];
    int val[MAXN];
    for (int i = 0; i < N; ++i) {
        scanf("%d %d", &vol[i], &val[i]);
    }

    int dp[MAXV + 1] = {0};

    for (int i = 0; i < N; ++i) {
        int w = vol[i];
        int c = val[i];
        for (int j = V; j >= w; --j) {
            if (dp[j - w] + c > dp[j])
                dp[j] = dp[j - w] + c;
        }
    }

    printf("%d\n", dp[V]);
    return 0;
}

[分析] 
1. 本题要求每件物品仅能选择一次，需在背包容量 V 内，选择物品使得总
价值最大。
2. 定义一维数组 dp[V+1] ，dp[j] 表示背包容量为 j 时能装的最大价值，初始
化为 0。对每件物品，从后往前遍历背包容量（避免重复选同一件物品）：
dp[j] = \max(dp[j], dp[j - v_i] + w_i)其中 v_i 是第 i 件物品体积，w_i 是价值， 且 j \geq v_i。
"用『阶段-状态-决策』的三层语言，把『每件物品只能选
一次』翻译成最优化方程，再决定用记忆化搜索还是递推，最后用单调
性优化。" 3. 输入：先读 N 和 V，再依次读 N 组 v_i 和 w_i。
4. 输出：最终 dp[V] 即为最大价值。 
---
[ID:4]
[answer]
#include <stdio.h>
#include <ctype.h>
#include <string.h>
char d[26] = {'V','W','X','Y','Z','A','B','C','D','E','F','G',
'H','I','J','K','L','M','N','O','P','Q','R','S','T','U'};
int main(void)
{
    char a[256], b[256], c[256];
	while (fgets(a, sizeof(a), stdin),
	fgets(b, sizeof(b), stdin),
	fgets(c, sizeof(c), stdin),
	strcmp(a, "ENDOFINPUT\n") != 0)
{
	int len = strlen(b);
	int i;
	for (i = 0; i < len; ++i) {
		if (isalpha((unsigned char)b[i])) {
	int t = b[i] - 'A';
	putchar(d[t]);
	} 
		else {
	putchar(b[i]);
		}
	}
}
return 0;
}

[分析] 
1.加密：明文 A→ 后 5 位 F；明文 V→ 后 5 位 A（字母表循环）
2.解密：密文 A→ 前 5 位 V；密文 F→ 前 5 位 A；密文 Z→ 前 5 位 U
3.字符处理规则:密文中的大写字母：按上述前 5 位的规则解密。
4.数学计算方式:对大写字母 c （ASCII 码），解密后的字符 ASCII 码计
算公式：明文 ASCII= (密文 ASCII- 65 - 5 + 26)% 26 + 65 是 A 的 ASCII
码，减 65 将字母映射到 0-25 的数值范围。
5.减 5 实现“前 5 位”的解密逻辑，加 26 再取模 26 是为了处理循环（如
A 减 5 会出现负数的情况）。
6.最后加 65 还原为大写字母的 ASCII 码
---
[ID:5]
[answer]
#include<stdio.h>
int main(){
int a,b,c,d;
scanf("%d %d %d %d",&a,&b,&c,&d);
int re=a*b+c*d;
printf("%d",re);
return 0;
}

[分析] 
1. 先定义 4 个整型，并给其赋值。
2. 然后将这四个整型按照题目计算，结果赋值给新整型， 并打印出这个新整型。
---
[ID:6]
[answer]
#include<stdio.h>
long long memo[1000];
int feb(int a){
	if(a>2){ memo[a-1]=memo[a-2]+memo[a-3]; return memo[a-1];
	}
		else if(a==1){ memo[0]=0; return memo[0];
		}
		else if(a==2){ memo[1]=1; return memo[1];
		}
	}
	int main(){
		int N; scanf("%d",&N);
		int j;
		for(int i=1;i<=N;i++){
			j=feb(i);
			printf("%d ",j);
		}return 0;
	}

[分析] 
1. 本题要求打印斐波那契数列，并且要求能够显示其前 45 位。
2. 斐波那契数列的最显著特征是递归思维。所以我们采用函数递归来写。
3. 先宏定义一个“记忆数组”，保存递归结果，便于下次递归时直接调用。
4. 然后写一个递归函数，并且强调 1、2 位数是给定的 0、1. 5. 然后编写主函数，调用递归函数，得到数列。
---
[ID:7]
[answer]
#include <stdio.h>
	int a[1001];
	void quick_sort(int l, int r)
	{
		if (l >= r) return;
		int i = l, j = r, pivot = a[(l + r) >> 1];
			while (i <= j)
		{
			while (a[i] < pivot) ++i;
			while (a[j] > pivot) --j;
		if (i <= j)
	{
		int t = a[i]; a[i] = a[j]; a[j] = t;
		++i; --j;
	}
		}
		quick_sort(l, j);
		quick_sort(i, r);
	}
	int main(void)
	{
		int n;
		if (scanf("%d", &n) != 1) return 0;
		int i;
		for (i = 1; i <= n; ++i) scanf("%d", &a[i]);
		quick_sort(1, n);
		for (i = 1; i <= n; ++i)
		if (i == 1 || a[i] != a[i - 1])
		printf("%d ", a[i]);
		return 0;
	}
	
[分析] 
1. 去重：删除数组中重复的整数元素，仅保留唯一值。
2. 排序：将去重后的数组按从小到大的顺序排列并输出。
3. 标记出现的元素：遍历输入数组，将对应数值的标记位设为 1（表示已
出现）。
4. 输出结果：从 1 到 1000 遍历标记数组，输出标记为 1 的下标，天然实
现从小到大排序和去重。
---
[ID:8]
[answer]
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#define N 10
char g[N][N];
static bool dfs(int x, int y)
{
	if (y == 9) return true;
	if (x == 9) return dfs(0, y + 1);
	if (g[x][y] != '.') return dfs(x + 1, y);
	bool st[N];
	memset(st, 0, sizeof(st));
	for (int i = 0; i < 9; ++i)
		if (g[i][y] >= '1' && g[i][y] <= '9')
			st[g[i][y] - '0'] = true;
	for (int i = 0; i < 9; ++i)
		if (g[x][i] >= '1' && g[x][i] <= '9')
			st[g[x][i] - '0'] = true;
	int sx = x / 3 * 3, sy = y / 3 * 3;
	for (int i = sx; i < sx + 3; ++i)
	for (int j = sy; j < sy + 3; ++j)
		if (g[i][j] >= '1' && g[i][j] <= '9')
			st[g[i][j] - '0'] = true;
	for (int i = 1; i <= 9; ++i)
		if (!st[i])
		{
			g[x][y] = '0' + i;
		if (dfs(x + 1, y)) return true;
		}
			g[x][y] = '.';
	return false;
}
	int main(void)
	{
	for (int i = 0; i < 9; ++i)
		scanf("%9s", g[i]);
		dfs(0, 0);
	for (int i = 0; i < 9; ++i, putchar('\n'))
	for (int j = 0; j < 9; ++j)
		putchar(g[i][j]);
	return 0;
	}
	
[分析] 
1.数独的核心约束规则
要填充 9×9 的数独矩阵，需满足三个条件：
①行唯一：每一行的数字 1-9 不重复；
②列唯一：每一列的数字 1-9 不重复；
③九宫格唯一：每个 3×3 的九宫格内数字 1-9 不重复。
2.回溯算法的执行逻辑
①确定搜索顺序：从数独的第一个空位置（即字符为 . 的位置）开始，
按行优先的顺序（从第 0 行到第 8 行，每行从第 0 列到第 8 列）依次尝试填
充数字。
②尝试合法数字：对当前空位置 (x, y) ，遍历数字 1~9，检查该数字是
否满足数独的三个约束规则：检查第 x 行是否已存在该数字；检查第 y 列是
否已存在该数字；确定 (x, y) 所属的九宫格（行区
间 (x//3)*3-(x//3)*3+2，列区间 (y//3)*3 -(y//3)*3+2），检查该九宫
格内是否已存在该数字。
③若数字合法，则将其填入 (x, y) 位置，继续递归处理下一个空位置。
3. 回溯与终止
①若递归过程中遇到无法填充合法数字的情况，说明当前选择的数字错误，
执行回溯：将当前位置恢复为 . ，回到上一步重新选择数字。
②若递归到没有空位置（即数独已填满），说明找到唯一解，直接返回结果
（题目保证数据有唯一解，找到解后可立即终止所有递归）。
---
